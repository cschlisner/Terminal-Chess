package uniChess;

import java.util.ArrayList;
import java.util.List;

/**
*	An object holding a boardstate. Each Board holds an array of 64 Tiles, any of which can be occupied by a Piece.
*	A board state will never actually change. When performMove() is called a new board is generated with the new boardstate.
*	This means that all information about this board (including legal moves, piece locations, etc) is in an artificial static state.
*	<p> 
*	Since all information about the board will never change, two lists of legal moves for each player is generated on creation. 
*	These lists will be publicly accessible and unchanging so that no additional calculations will need to be done for the board.
*/
public class Board {

	/** Board iteration, generated from previous board - same as game move count **/
	public int iteration;

	private int blackMaterial=0;
	private int whiteMaterial=0;

	private Tile[][] state = new Tile[8][8];

	private List<Move> legalWhiteMoves;
	private List<Move> legalBlackMoves;

	private List<Move> validWhiteMoves;
	private List<Move> validBlackMoves;

	private List<Piece> deathRow = new ArrayList<>();


	/** Sets the orientation of the string representation of the board. */
	public static boolean reversed;

	/**
	 * Creates a copy of a given board
	 * @param other Board to copy
	 */
	public Board(Board other){
		this(other, null);
	}

	/**
	 * Creates the Board resulting from a given move on a given parent board
	 * @param parent Parent Board
	 * @param move Move made
	 */
	public Board(Board parent, Move move){
		iteration = parent.iteration + (move==null ? 0 : 1);

		for (int y = 0; y < 8; ++y) {
			for (int x = 0; x < 8; ++x) {
				state[y][x] = new Tile(parent.getTile(x, 7 - y));
				Piece p = state[y][x].getOccupator();
				if (p != null){
					if (p.color.equals(Game.Color.WHITE))
						whiteMaterial += p.value;
					else blackMaterial += p.value;

					// clear en passant moves each turn (after 1 turn, enemy loses ability to en passant)
					// if the move that generated this board make a Pawn en-passant-able, the pawn's
					// passable value will be set after this board has been generated by the parent
					// board.
					if (move != null && p.type.equals(Game.PieceType.PAWN))
						p.passable = false;
				}
			}
		}
		this.deathRow.addAll(parent.deathRow);

		if (move != null){

			// make the move
			this.moveOccupator(move.origin, move.destination);

			// set passable status (able to be en-passanted) of pawn if it's the pawns first move
			if (move.movingPiece.ofType(Game.PieceType.PAWN) &&
					move.movingPiece.moves==0){
				int dx = move.destination.x - move.origin.x;
				int dy = (move.movingPiece.color.equals(Game.Color.WHITE) ? 1 : -1) * (move.destination.y - move.origin.y);
				getTile(move.destination).getOccupator().passable = (dy == 2 && dx == 0);
			}
			if (move.ENPASSE) {
				int mx = move.origin.x + (move.destination.x - move.origin.x);
				addToDeathRow(this.getTile(mx, move.origin.y).getOccupator());
				getTile(mx, move.origin.y).setOccupator(null);
			}
			else if (move.KCASTLE) {
				moveOccupator(new Location(move.origin.x+3, move.origin.y), new Location(move.origin.x+1, move.origin.y));
			}
			else if (move.QCASTLE) {
				moveOccupator(new Location(move.origin.x-4, move.origin.y), new Location(move.origin.x-1, move.origin.y));
			}
			else if (move.PROMOTION) {
				getTile(move.destination).getOccupator().type = Game.PieceType.QUEEN;
			}

			if (move.materialValue > 0) {
				addToDeathRow(parent.getTile(move.destination).getOccupator());
			}
		}
		else if (iteration>0){
			// these values have already been calculated and haven't changed
			if (iteration%2==0)
				this.legalWhiteMoves = parent.getLegalMoves(Game.Color.WHITE);
			else this.legalBlackMoves = parent.getLegalMoves(Game.Color.BLACK);
		}
	}

	public Board(){
		iteration = 0;
		for (int y = 0; y < 8; ++y) {
			for (int x = 0; x < 8; ++x) {
				state[y][x] = new Tile(new Location(x, 7 - y));
				Piece p = state[y][x].getOccupator();
				if (p != null) {
					if (p.color.equals(Game.Color.WHITE))
						whiteMaterial += p.value;
					else blackMaterial += p.value;
				}
			}
		}

		createMaterial(Game.Color.BLACK);
		createMaterial(Game.Color.WHITE);
	}

	public Board(String layout) throws Exception{
		if (layout.length() != 64)
			throw new Exception("NO!!!!!!!!!!");

		char[] allowed = {'.','p','b','k','n','r','q'};

		for (int i = 0; i < 64; ++i) {

			int y = i / 8, x = i <= 7 ? i : i - 8 * y;

			boolean inset = false;
			for (int a = 0; a < allowed.length; ++a){
				if (Character.toLowerCase(layout.charAt(i)) == allowed[a]) {
					inset = true;
					break;
				}
			}
			if (!inset)
				throw new Exception("NO!!!!!!!!!!!!!!");

			state[y][x] = new Tile(new Location(x, 7-y));
			if (layout.charAt(i) != '.')
				state[y][x].setOccupator(Piece.synthesizePiece(layout.charAt(i)));
		}
	}

	public String getLayout(){
		String boardlayout = "";
		for (int i = 0; i < 64; ++i){
			int y = i/8, x = i <=7 ? i : i - 8 * y;
			if (getTile(x,7-y).getOccupator() != null)
				boardlayout += getTile(x,7-y).getOccupator().getSymbol(false);
			else boardlayout += ".";
		}
		return boardlayout;
	}

	private void createMaterial(Game.Color color){
   		int d = (color.equals(Game.Color.BLACK))?-1:1;
        Location org = (d>0)?new Location(0,0):new Location(7,7);

        getTile(org.x+(d*0), org.y).setOccupator(new Piece(color, Game.PieceType.ROOK));
        getTile(org.x+(d*7), org.y).setOccupator(new Piece(color, Game.PieceType.ROOK));

        getTile(org.x+(d*1), org.y).setOccupator(new Piece(color, Game.PieceType.KNIGHT));
        getTile(org.x+(d*6), org.y).setOccupator(new Piece(color, Game.PieceType.KNIGHT));

       getTile(org.x+(d*2), org.y).setOccupator(new Piece(color, Game.PieceType.BISHOP));
       getTile(org.x+(d*5), org.y).setOccupator(new Piece(color, Game.PieceType.BISHOP));

        // King and queen are symmetrical
        getTile(org.x+(d*((d>0)?4:3)), org.y).setOccupator(new Piece(color, Game.PieceType.KING));
        getTile(org.x+(d*((d>0)?3:4)), org.y).setOccupator(new Piece(color, Game.PieceType.QUEEN));

        for (int i = 0; i < 8; ++i)
           getTile(i, ((d>0)?org.y+1:org.y-1)).setOccupator(new Piece(color, Game.PieceType.PAWN));
    }


    public int getMaterialCount(Game.Color color){
		return (color == Game.Color.BLACK) ? blackMaterial : whiteMaterial;
	}

    protected List<Tile> tileList = new ArrayList<>();
    /**
    *	@return A list of this Board's Tile objects 
    */
    public List<Tile> getTileList(){
        if (tileList.isEmpty()) {
            for (int i = 0; i < 8; ++i)
                for (int j = 0; j < 8; ++j)
                    tileList.add(state[i][j]);
        }
        return tileList;
    }

    /** 
    *	Returns the Tile object at a certain location, with the bottom left corner of the board 
    *	defined as (0,0) and the top right defined as (7,7).
    *	
    *	@param l The location of the tile to return
    *	@return The tile at the specified location
    */
    public Tile getTile(Location l){
		return getTile(l.x, l.y);
	}
	
	/** 
    *	Returns the Tile object at a certain location, with the bottom left corner of the board 
    *	defined as (0,0) and the top right defined as (7,7).
    *	
    *	@param x x-coordinate of the specified Tile
    *	@param y y-coordinate of the specified Tile 
    *	@return The Tile at the specified location
    */
	public Tile getTile(int x, int y){
		return state[7-y][x];
	}

	/** 
    *	Returns a two-dimensional array of Tile objects wherein array[0][0] is the top left corner
    *	of the board and array[7][7] is the bottom right.
    *	
    *	@return The array of Tile objects
    */
	public Tile[][] getBoardState(){
		return state;
	}

	/**
	 * Get string of captured pieces of a certain color
	 * @param color color of captured pieces
	 * @return string of captured pieces in order of capture
	 */
	public String displayDeathRow(Game.Color color){
		StringBuilder res = new StringBuilder();
		res.append("   ");
		for (Piece p : deathRow)
			if (p.color.equals(color))
				res.append(p + " ");
		return res.toString();
	}

	private String writeColumnLabels(int max, boolean reversed){
		StringBuilder res = new StringBuilder();
		res.append(" ");
		for (int x = 0; x<9; ++x){
			if (x>0) res.append((" ABCDEFGH".charAt((reversed)?9-x:x)));
			for (int k=0;k<(max-1);++k)	
				res.append(" ");
		}
		res.append("\n");
		return res.toString();
	}

	private static <T> int findMaxLen(T[][] arr){
		int max=0;
		for (T[] row : arr)
			for (T el : row)
		 max = (String.valueOf(el).length() > max)?String.valueOf(el).length():max;
		return max;
    }
	public String getBoardString(){
		return getBoardString("","");
	}
	private String getBoardString(Player whiten, Player blackn){
		return getBoardString(whiten.toString(), blackn.toString());
	}
	private String getBoardString(String whiten, String blackn){
		StringBuilder res = new StringBuilder();
		
		int max = findMaxLen(getBoardState());
		int y = 8;
		res.append("\n\n"+displayDeathRow(reversed ? Game.Color.BLACK : Game.Color.WHITE)+"\n");
		res.append("        "+(reversed ? whiten : blackn)+"\n");
		res.append(writeColumnLabels(max, reversed)+"\n");
		if (!reversed){
			for (Board.Tile[] row : getBoardState()){
				res.append(y+" ");
				for (Board.Tile el : row){
					res.append(el);
					for (int k=0;k<((max-String.valueOf(el).length()));++k)	
						res.append("  ");
				}
				res.append("  "+(y--)+"\n");
			}
		} else {
			for (int i = getBoardState().length-1; i >= 0; --i){
				res.append(y-i);
				for (int j = getBoardState()[0].length-1; j >= 0; --j){
					res.append(getBoardState()[i][j]);
					for (int k=0;k<((max-String.valueOf(getBoardState()[i][j]).length()));++k)	
						res.append(" ");
				}
				res.append(" "+(y-i)+"\n");
			}
		}
		res.append("\n"+writeColumnLabels(max, reversed));
		res.append("        "+(reversed ? blackn : whiten)+"\n");
		res.append(displayDeathRow(reversed ? Game.Color.WHITE : Game.Color.BLACK)+"\n\n");

		return res.toString();
	}

	/**
	*	Returns whether or not a line of sight between two Locations is 'clear' 
	*	(has no Pieces between them) in the up, down, left, right directions.
	*
	*	@param a The first location
	*	@param b The second location
	*	@return Whether the cardinal line of sight between two tiles contains no pieces
	*/
	public boolean cardinalLineOfSightClear(Location a, Location b){
		int xDiff = b.x-a.x;
		int yDiff = b.y-a.y;
		
		// v (vector) = x or y direction | x = false | y = true
		boolean v;
		
		if (yDiff == 0 ^ xDiff == 0) 
			v = (xDiff==0);
		else return false;

		int dir = (((v)?b.y:b.x) < ((v)?a.y:a.x))?1:-1;
		for (int i = ((v)?b.y:b.x)+dir; i != ((v)?a.y:a.x); i += dir){
			Tile t = getTile((v)?a.x:i, (v)?i:a.y);
			if (t.occupator != null)
				return false;
		}
		return true;
	}

	/**
	*	Returns whether or not a line of sight between two Locations is 'clear' 
	*	(has no Pieces between them) in the diagonal directions.
	*
	*	@param a The first location
	*	@param b The second location
	*	@return Whether the diagonal line of sight between two tiles contains no pieces
	*/
	public boolean diagonalLineOfSightClear(Location a, Location b){
		int xDiff = b.x-a.x;
		int yDiff = b.y-a.y;

		// if (xDiff + yDiff == 0) then x and y are of opposite signs, check y = -x diagonal
		if (yDiff == 0 || xDiff == 0) return false;

		int xDir = (xDiff>0)?-1:1;
		int yDir = (yDiff>0)?-1:1;

		if (Math.abs(xDiff) != Math.abs(yDiff)) 
			return false;

		for (int x = b.x+xDir, y = b.y+yDir; x != a.x; x+=xDir, y+=yDir){
			if (getTile(x, y).occupator != null)
				return false;
		}
		return true;
	}


	/**
	*	Returns the distance from a given location to the king of the given color
	*
	*	@param color The color of the king to get the distance for
	*	@param locale The location to calculate the distance for
	*	@return The distance from the given location to the king of the given color
	*/
	public double getDistanceFromKing(Game.Color color, Location locale){
		Location kingLoc = null;
		for (Tile t : getTileList()){
			if (t.getOccupator()!=null && t.getOccupator().type.equals(Game.PieceType.KING) && t.getOccupator().color.equals(color)){
				kingLoc = t.getLocale();
				break;
			}
		}

		return getDistanceFromLocation(locale, kingLoc);
	}	

	/**
	*	Returns the net distance from one location to anoter location on the board
	*	
	*	@param a The original location
	*	@param b The destination
	*	@return The net distance between the two locations
	*/
	public double getDistanceFromLocation(Location a, Location b){
		return Math.sqrt(Math.pow((double)Math.abs(a.x-b.x), 2) + Math.pow((double)Math.abs(a.y-b.y), 2));
	}

	/**
	*	Determines whether a given move is valid according to the move's origin piece's defined move set.
	* 
	*	@return Whether the move is valid according to the relevant piece's move set 
	*/
	public boolean isValidMove(Move move){
		boolean validMove = false;

		Piece movingPiece = getTile(move.origin).getOccupator();
		
		if (!move.destination.onBoard() || !move.origin.onBoard())
			return false;

		if (movingPiece == null || !getTile(move.destination).available(movingPiece.color) || move.origin.equals(move.destination))
			return false;
		
		int direction = movingPiece.color.equals(Game.Color.WHITE) ? 1 : -1;

		// delta x and y
		int dx = move.destination.x - move.origin.x;
		int dy = direction * (move.destination.y - move.origin.y);

		boolean enemy = getTile(move.destination).getOccupator() != null;
		
		switch (movingPiece.type){
			case PAWN:
				Piece enpasse = (dy == 1 && (dy + dx == 0 || dy + dx == 2)) ? getTile(move.origin.x+dx, move.origin.y).getOccupator() : null;
				move.PROMOTION = (move.destination.y == (movingPiece.color.equals(Game.Color.WHITE) ? 7 : 0));
				if ((dy == 1 && dx == 0 && !enemy)
					|| (movingPiece.moves==0 && dy == 2 && dx == 0 && cardinalLineOfSightClear(move.origin, move.destination) && !enemy)
					|| (dy == 1 && (dy + dx == 0 || dy + dx == 2) && enemy)){
					validMove = true;
					break;
				}
				else if (!enemy &&
							enpasse != null &&
							getTile(move.origin.x+dx, move.origin.y).available(movingPiece.color) && 
							enpasse.passable){
					move.ENPASSE = true;
					validMove = true;
					break;
				}
				validMove = false;
				break;
			
			case ROOK:
				validMove = (cardinalLineOfSightClear(move.origin, move.destination));
				break;

			case KNIGHT:
				validMove = (dx != 0 && dy != 0 && Math.abs(dx) + Math.abs(dy) == 3);
				break;
			
			case BISHOP:
				validMove = (diagonalLineOfSightClear(move.origin, move.destination));
				break;
			
			case QUEEN:
				validMove = (diagonalLineOfSightClear(move.origin, move.destination))
						^ (cardinalLineOfSightClear(move.origin, move.destination));
				break;
			
			case KING:	
				if (movingPiece.moves==0 && Math.abs(dx) == 2 && dy == 0){
					if (dx > 0){
						Piece castleRook = getTile(move.origin.x+3, move.origin.y).getOccupator();

						// TODO: add logic to check if the king crosses over a square in which it would be in check
						if (cardinalLineOfSightClear(move.origin, new Location(move.origin.x+3, move.origin.y)) &&
						 	castleRook != null && castleRook.type.equals(Game.PieceType.ROOK) && castleRook.moves==0)
							move.KCASTLE = true;
						else {
							validMove = false;
							break;
						}
					}
					else {
						Piece castleRook = getTile(move.origin.x-4, move.origin.y).getOccupator();

						// TODO: add logic to check if the king crosses over a square in which it would be in check
						// TODO: cardinal line of sight clear is broke here
						if (cardinalLineOfSightClear(move.origin, new Location(move.origin.x-4, move.origin.y)) &&
							castleRook != null && castleRook.type.equals(Game.PieceType.ROOK) && castleRook.moves==0)
							move.QCASTLE = true;
						else {
							validMove = false;
							break;
						}
					}
					validMove = true;
					break;
				}
				validMove = (Math.abs(dx) <= 1 && Math.abs(dy) <= 1);
				break;
		}


		if (validMove && enemy){
			Piece enemyPiece = getTile(move.destination).getOccupator();
			move.materialValue = enemyPiece.value;
			enemyPiece.attackingMove = move;
		}

		return validMove;
	}

	/**
	*	Computes a list of all valid moves for all pieces of a given color
	* 
	*	@param color The color to gather moves for
	*	@return The list of moves
	*/
	private List<Move> calculateValidMoves(Game.Color color){
		List<Move> moves = new ArrayList<>();
		for (Tile t : getTileList()){
            if (!t.available(color)){
				List<Move> m_list = new ArrayList<>();
				Location ploc = t.getLocale();
				int direction = color.equals(Game.Color.WHITE) ? 1 : -1;
				switch (t.getOccupator().type){
					case PAWN:
						m_list.add(new Move(ploc, new Location(ploc.x, ploc.y+(direction*2)), this));
						m_list.add(new Move(ploc, new Location(ploc.x, ploc.y+(direction*1)), this));
						m_list.add(new Move(ploc, new Location(ploc.x+1, ploc.y+(direction*1)), this));
						m_list.add(new Move(ploc, new Location(ploc.x-1, ploc.y+(direction*1)), this));
						break;

					case ROOK:
						for (int i = 0; i < 8; ++i){
							if (i != ploc.x)
								m_list.add(new Move(ploc, new Location(i, ploc.y), this));
							if (i != ploc.y)
								m_list.add(new Move(ploc, new Location(ploc.x, i), this));
						}
						break;

					case KNIGHT:
						int[][] pos = {
								{2, 1},
								{2, -1},
								{-2, 1},
								{-2, -1},
								{1, 2},
								{1, -2},
								{-1, 2},
								{-1, -2}
						};
						for (int[] p : pos)
							m_list.add(new Move(ploc, new Location(ploc.x+p[0], ploc.y+p[1]), this));
						break;

					case BISHOP:
						for (int i = 1; i < 8; ++i){
							m_list.add(new Move(ploc, new Location(ploc.x+i, ploc.y+i), this));
							m_list.add(new Move(ploc, new Location(ploc.x+i, ploc.y-i), this));
							m_list.add(new Move(ploc, new Location(ploc.x-i, ploc.y+i), this));
							m_list.add(new Move(ploc, new Location(ploc.x-i, ploc.y-i), this));
						}
						break;

					case QUEEN:
						for (int i = 0, j= 1; i < 7; ++i, ++j){
							if (i != ploc.x)
								m_list.add(new Move(ploc, new Location(i, ploc.y), this));
							if (i != ploc.y);
								m_list.add(new Move(ploc, new Location(ploc.x, i), this));
							
							m_list.add(new Move(ploc, new Location(ploc.x+j, ploc.y+j), this));
							m_list.add(new Move(ploc, new Location(ploc.x+j, ploc.y-j), this));
							m_list.add(new Move(ploc, new Location(ploc.x-j, ploc.y+j), this));
							m_list.add(new Move(ploc, new Location(ploc.x-j, ploc.y-j), this));
						}
						break;

					case KING:
						for (int i = 0; i < 3; ++i)
							for (int j = 0; j < 3; ++j)
								m_list.add(new Move(ploc, new Location(ploc.x-1+i, ploc.y+1-j), this));
						// potential castling moves
						if (t.getOccupator().moves == 0){
							m_list.add(new Move(ploc, new Location(ploc.x+2, ploc.y), this));
							m_list.add(new Move(ploc, new Location(ploc.x-2, ploc.y), this));
						}
						break;
				}
				for (Move move : m_list){
					if (isValidMove(move))
						moves.add(move);
				}
            }
		}
		return moves;
	}

	/**
	*	Returns the list of valid moves for a given color if this method has been called before. 
	*	Otherwise, it will generate the list and return it. 
	* 
	*	@param color The color to gather moves for
	*	@return The list of moves
	*/
	public List<Move> getValidMoves(Game.Color color){
		if (color.equals(Game.Color.BLACK)){
			if (validBlackMoves == null) validBlackMoves = calculateValidMoves(color);
			return validBlackMoves;
		}
		if (validWhiteMoves == null) validWhiteMoves = calculateValidMoves(color);
		return validWhiteMoves;
	}

	/**
	*	Determines whether a given player on a given board holds check.
	*	
	*	@param board The board to check on 
	*	@param c The color of player to check for
	*	@return Whether the player has check 	
	*/
	public static boolean playerHasCheck(Board board, Game.Color c){
		Piece p;
		for (Move m : board.getValidMoves(c)){
			p = board.getTile(m.destination).getOccupator();
			if (p != null && p.ofType(Game.PieceType.KING))
				return true;
		}
		return false;
	}

	public static boolean playerHasCheck(Board board, Player player){
		return Board.playerHasCheck(board, player.color);
	}

	/**
	*	Computes a list of all legal moves for all pieces of a given color
	* 
	*	@param c The color to gather moves for
	*	@return The list of moves
	*/
	public List<Move> calculateLegalMoves(Game.Color c){
		List<Move> validMoves = getValidMoves(c);
		List<Move> legalMoves = new ArrayList<>();
		//long t1 = System.currentTimeMillis();
		for (Move m : validMoves){
			if (!Board.playerHasCheck(new Board(this, m), Game.getOpposite(c))) {
				legalMoves.add(m);
			}
			else if (m.materialValue > 0) {
				getTile(m.destination).getOccupator().attackingMove = null;
			}
		}
		//System.out.println("Calculated legal in "+(System.currentTimeMillis() - t1)+"ms");

		return legalMoves;
	}

	/**
	*	Returns the list of legal moves for a given color if this method has been called before. 
	*	Otherwise, it will generate the list and return it. 
	* 
	*	@param color The color to gather moves for
	*	@return The list of moves
	*/
	public List<Move> getLegalMoves(Game.Color color){
		if (color.equals(Game.Color.BLACK)){
			if (legalBlackMoves == null) legalBlackMoves = calculateLegalMoves(color);
			return legalBlackMoves;
		}
		if (legalWhiteMoves == null) legalWhiteMoves = calculateLegalMoves(color);
		return legalWhiteMoves;
	}

	/**
	*	Returns the list of legal moves for a given player
	* 
	*	@param player The Opponent of the Player to gather moves for
	*	@return The list of moves
	*/
	public List<Move> getLegalMoves(Player player){
		return getLegalMoves(player.color);
	}

	/**
	*	Populates both legal move lists
	*	
	*/
	public void processLegal(){
		getLegalMoves(iteration % 2 == 0 ? Game.Color.WHITE : Game.Color.BLACK);
	}

	/**
	*	Returns the list of legal moves for a given player's opponent
	* 
	*	@param player The Opponent of the Player to gather moves for
	*	@return The list of moves
	*/
	public List<Move> getOpponentLegalMoves(Player player){
		return getOpponentLegalMoves(player.color);
	}

	/**
	*	Returns the list of legal moves for a given color's opponent
	*
	*	@param color The color of the Opponent of the Player to gather moves for
	*	@return The list of moves
	*/
	public List<Move> getOpponentLegalMoves(Game.Color color){
		return getLegalMoves(Game.getOpposite(color));
	}

	private void moveOccupator(Location a, Location b){
		getTile(b).setOccupator(getTile(a).getOccupator());

		++ getTile(a).getOccupator().moves;

		getTile(a).setOccupator(null);
	}

	public void addToDeathRow(Piece p){
		deathRow.add(p);
	}

	/**
	 * Returns the board iteration number, and which color has the move.
	 * @return Board iteration
	 */
	@Override
	public String toString(){
		return "Board#"+String.valueOf(iteration)+":"+(iteration%2==0 ? "White":"Black")+" to move.";
	}

	public void print(Player one, Player two){
		System.out.println(getBoardString(one, two));
	}

	public class Tile {
		private Piece occupator = null;
		private Location locale;
		public Game.Color color;

		public Tile(Location loc){
			locale = loc;
			occupator = null;
			color = ((loc.x+loc.y)%2==0)?Game.Color.BLACK:Game.Color.WHITE;
		}

		public Tile(Tile org){
			this.locale = org.locale;
			if (org.occupator != null)
				this.setOccupator(new Piece(org.occupator));
			this.color = org.color;
		}

		/**
		*	@return The location of this Tile
		*/
		public Location getLocale(){	
			return locale;
		}
		
		/**
		*	@return The occupator of this Tile
		*/
		public Piece getOccupator(){
			return occupator;
		}

		/**
		*	Returns whether this tile contains no piece or contains a piece with a color
		*	not equal to the given color. In other words, it returns whether or not a 
		*	Piece of the given color can move to this Tile.
		*	
		*	@param c The color to use
		*	@return Whether a piece of the given color can move to this tile.
		*/
		public boolean available(Game.Color c){
			return (occupator == null || !occupator.color.equals(c));
		}


		/**
		*	Sets the occupator of this Tile to a Piece
		*
		*	@param p The piece to use as the new occupator
		*/
		public void setOccupator(Piece p){
			occupator = p;
		}

		/**
		*	Returns a String representation of this Tile, including the 'color' of the tile and 
		*	any occupants (using the Game setting for unicode).
		*/
		@Override
		public String toString(){
			return " "+(((occupator!=null)?occupator.getSymbol():(color.equals(Game.Color.BLACK))? (Game.unicode?"\u00B7":"-"):" "))+" ";
		}
	}
}